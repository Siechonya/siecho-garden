---
{"dg-publish":true,"permalink":"/C++/4. C++模板(STL)/","noteIcon":"default","created":"2025-09-19T22:19:52.052+08:00","updated":"2025-09-20T22:24:41.873+08:00"}
---


# 1 Template(模板简介)  
## 1.1 类模板  
### 1.1.1 类模板的定义和初始化
类模版定义的开头是关键字 `template` 和一堆尖括号 `< ... >` 包裹的 Template Parameter List(模板形参列表)，模板形参可以是 Type Parameter (类型形参，关键字 `typename`)或 Nontype Parameter (非类型形参)，这也是为什么初始化官方的 `vector` 也需要尖括号，类似于：
```cpp
#include<vector>
vector<int> vec0; //only declare, vec0 is null
vector<int> vec00(3); //declare a int vector with length of 3, it's elements are default initial value
vector<int> vec1(3, 100); //declare a int vector with length of 3, all of it's elements are 100
```
创建一个类似于vector的带有模板的类来感受一下：
```cpp
// typename: 类型形参前的关键词，也可以用class代替
// T: 类型名的占位符，可以是任何名字
// 与标准库的vector不同，这个MyVector是固定大小的
template <typename T, int capacity> class MyVector {
	public:
		MyVector() : size(0), arr(new T[capacity]) {} // 初始化capacity大小的数组：size=0，arr = new int[5]
		~MyVector() { delete[] arr; } // 析构函数
		bool isEmpty() { return size == 0; } // 判断是否为空
		int getCapacity() { return capacity; }
		int getSize() { return size; }

 		void push(T item) {  // 从尾部添加元素
			if ( size == capacity ) {
				cout << "容量已满！" << endl;
				return;
			}
			arr[size++] = item;  // 先放新元素再累加size
		}

		bool pop(T &item) {  // 移除最后元素并返回是否成功(bool)
			if ( isEmpty() ) {
				return false;
			} else {
				item = arr[--size];  // 先递减size，再将item赋值为要弹出的元素
				return true;
			}
		}
		// 重载下标运算符`[]`，在越界的时候警告并返回第一个元素
		T &operator[](int i) {
			if ( i >= size || i >= capacity ) {
				cout << "下标越界！" << endl;
				return arr[0];
			} 
			else { return arr[i]; }
		}
	private:
		T *arr;  // 在本例中，类型形参T被初始化为`int`，所以此处创建 `int*`类型的变量`arr`
		int size;  // 当前元素个数
};

int main() {
	MyVector<int, 5> vec; // 容量为5的MyVector容器
	cout << "容器的容量为：" << vec.getCapacity() << endl;
	cout << "添加元素：" << endl;
	for ( int i = 0; i < 3; i++ ) {
		vec.push(i);
	}
	int size = vec.getSize();
	for ( int i = 0; i < size; i++ ) {
		cout << "容器的第" << i + 1 << "个元素为：" << vec[i] << endl;
	}
	cout << "移除元素：" << endl;
	while ( !vec.isEmpty() ) {
		int num;
		vec.pop(num);
		cout << "移除" << num << endl;
	}
	return 0;
}
-------------------------------------------------
输出：
容器的容量为：5
添加元素：
容器的第1个元素为：0
容器的第2个元素为：1
容器的第3个元素为：2
移除元素：
移除2
移除1
移除0
```

上例中，当我们定义 `MyVector<int, 5> vec;` 时，编译器就知道在编译的时候它需要创建一个新的类定义，其中所有的 `T` 都要替换成 `int`，而 `capacity` 都要替换成 `5`。编译器所要做的这些替换行为叫作模板实例化（Template Instantiation）。
### 1.1.2 类模板成员函数的定义分离  
当类模板的成员函数的声明在模板外时，语法也与类有所区别：
```cpp
template<class T>  class Interval{   // 区间模板
	public:
		Interval(T s, T e) : start(s), end(e) {}
		void print();  // 类模板的成员函数声明
	private:
		T start;
		T end;
};

template<class T>  void Interval<T>::print(){  // 类模板成员函数的定义
	cout << "[" << start << ", " << end << "]" << endl;
}

int main() {
	Interval<int> int1(3, 4);
	cout << "打印int1：" << endl;
	int1.print(); // -> [3, 4]
	return 0;
}
```
有两个东西是不能少的：
- `template` 关键字和模板形参列表。
- 作用域操作符 `::` 前的类名要加上模板形参 `<T>`。这是因为这里的成员函数也是类模板声明的一部分，我们必须标注它的模板特性，不然它就是一个特定版本（比如 ` Interval<int>`）的成员函数了。
## 1.2 函数模板  
### 1.2.1 一般函数和成员函数模板
与类模板类似，函数也可以声明成泛型的形式，包括一般的函数和类成员函数，都可以声明为模板：  
```cpp
#include <iostream>

class Interval{
	public:
		Interval(int s, int e) : start(s), end(e) {}
		int start;
		int end;
	
};
// 重载>使得模板max函数能比较Interval对象
bool operator>(const Interval &lhs, const Interval &rhs) {
	if ( lhs.start > rhs.start ) {
		return true;
	} else if ( lhs.start == rhs.start ) {
		return (lhs.end > rhs.end);
	} else {
		return false;
	}
}
// 重载输出操作符使得打印区间方便一些
std::ostream& operator<<(std::ostream& out, const Interval& i){
	out << "[" << i.start << ", " << i.end << "]";
    return out;
}

template <class T>  T max(const T &a, const T &b) {  // 函数模板
	return (a > b ? a : b);
}

int main() {
	int a = 3;
	int b = 4;
	std::cout << "a和b之间的最大值是：" << max<int>(a, b) << std::endl; // -> 4
	Interval int1(1, 2);
	Interval int2(1, 3);
	std::cout << "int1和int2之间的最大值是：" << max<Interval>(int1, int2) << std::endl; // -> [1, 3]
	return 0;
}
```
调用模板函数时，除了函数名和实参，还要加上模板形参。另外，因为自定义的函数模板 `max()` 会与 `std` 命名空间的冲突，所以上例没有使用标准命名空间。

除了一般函数外，函数模板也适用于类成员函数，甚至是类模板的成员函数。也就是说，类模板的成员函数除了类本身的模板形参之外，还有函数自身带的模板形参。  
```cpp
template<typename T> class Vector2D{ // 二维向量
	public:
		Vector2D(T X, T Y) : x(X), y(Y) {}
		// 加法重载函数的右操作数使用成员函数的模板形参类型
		template<typename RType>   Vector2D add(const RType &rhs);
		void print() {
			cout << "(" << x << ", " << y << ")" << endl;
		}
	private:
		T x;
		T y;
};
// 两个模板形参表都要有
template <typename T> template <typename RType> 
Vector2D<T> Vector2D<T>::add(const RType &rhs) {
	this->x += rhs;
	this->y += rhs;
	return *this;
}

int main() {
	Vector2D<int> v1(1, 2);
	int intNum = 3;
	float floatNum = 1.9;
	cout << "v1加上intNum的结果为：" << endl; 
	(v1.add<int>(intNum)).print();  // -> (4, 5)
	cout << "v1加上floatNum的结果为：" << endl;
	(v1.add<float>(floatNum)).print();  // -> (5, 6)
	return 0;
}
```
### 1.2.2 默认模板形参  
模板形参也可设置默认参数，这与函数声明中的默认参数的用法非常相似。
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 二维矩阵
// 默认参数：类型T=int，行m=2，列n=2
template <typename T = int, int m = 2, int n = 2>
class Matrix{
	public:
		// T()会调用T类型的默认构造函数，如果是int()的话就是初始化为0
		Matrix(T val = T()){
			row = m;
			col = n;
			mat = vector<vector<T>>(row, vector<T>(col, val)); // 创建一个row行col列的矩阵，每个元素初始化为val
		}
		void print() {  // 打印矩阵
			for ( int i = 0; i < row; i++ ) {
				for ( int j = 0; j < col; j++ ) {
					cout << mat[i][j] << " ";
				}
				cout << endl;
			}
		}
	private:
		int row;
		int col;
		vector<vector<T>> mat; // 矩阵
};

int main() {
	// 就算使用默认参数也要加上空的尖括号对！
	Matrix<> mat1;
	cout << "打印mat1：" << endl;
	mat1.print();
	// 部分使用默认参数
	Matrix<string, 3> mat2("零壹快学");
	cout << "打印mat2：" << endl;
	mat2.print();

	Matrix<float, 3, 3> mat3(1.0);
	cout << "打印mat3：" << endl;
	mat3.print();
	return 0;
}
-------------------------------------------------------------------------
输出：
打印mat1：
0 0 
0 0 
打印mat2：
零壹快学 零壹快学 
零壹快学 零壹快学 
零壹快学 零壹快学 
打印mat3：
1 1 1 
1 1 1 
1 1 1 
```
## 1.3 * Template Specialization (模板特化)  
### 1.3.1 模板特化
在 [[#2.1 一般函数和成员函数模板]] 的第二个代码示例中，我们实现了add()函数，将Vector2D与某一类型相加，但是函数的实现却决定了这个类型只能是基本类型，并且在两个分量加上相同的数值，或是重载加法能返回特定数值的类。想实现 `Vector2D` 与 `Vector2D` 的分量相加，可以用模板特化：  
```cpp
#include <iostream>
using namespace std;

// 模板特化
// Author: 零壹快学

// 二维向量
template<typename T>  class Vector2D{
	public:
		Vector2D(T X, T Y) : x(X), y(Y) {}
		// 加法重载函数的右操作数使用成员函数的模板形参类型
		template<typename RType>  Vector2D add(const RType &rhs);
		void print() {
			cout << "(" << x << ", " << y << ")" << endl;
		}
	private:
		T x;
		T y;
};
// 两个模板形参表都要有
template <typename T> template <typename RType>
Vector2D<T> Vector2D<T>::add(const RType &rhs) {
	this->x += rhs;
	this->y += rhs;
	return *this;
}
// 对于要特化的模板形参表我们只保留空的尖括号对
template <> template <>
Vector2D<int> Vector2D<int>::add(const Vector2D<int> &rhs) {
	this->x += rhs.x;
	this->y += rhs.y;
	return *this;
}
int main() {
	Vector2D<int> v1(1, 2);
	Vector2D<int> v2(5, 7);
	int intNum = 3;
	cout << "v1加上intNum的结果为：" << endl;
	(v1.add<int>(intNum)).print();
	cout << "v1加上v2的结果为：" << endl;
	(v1.add<Vector2D<int>>(v2)).print();
	return 0;
}
-------------------------------------------------------------
输出：
v1加上intNum的结果为：
(4, 5)
v1加上v2的结果为：
(9, 12)
```
可以看到，为了防止两个向量相加 `v1.add<Vector2D<int>>(v2)` 报错 `no match for 'operator+=' (operand types are 'int' and 'const Vector2D<int>)`，增加了对函数模板的类型参数为 `Vector2D<int>` 的情况的特殊处理：  
```cpp
// 对于要特化的模板形参表我们只保留空的尖括号对
template <> template <>
Vector2D<int> Vector2D<int>::add(const Vector2D<int> &rhs) {
	this->x += rhs.x;
	this->y += rhs.y;
	return *this;
}
```
开头的 `template <> template <>` 让编译器知道这还是一个跟模板有关的函数，形参表为空是因为类型形参已确定，不需要填。  
### 1.3.2 Partial Specialization (偏特化)
我们也可以只对模板的一部分模板形参做特化，而另一部分仍作为动态的参数，也就是偏特化（Partial Specialization）：  
```cpp
#include <iostream>
#include <vector>
using namespace std;

template<typename T, int dim>  class MyVec{ // N维向量
	public:
		MyVec(const vector<T> &Vec): vec(Vec) {
			if ( Vec.size() != dim ) {
				cout << "传入vector大小不等于dim！" << endl;
			}
		}; 
		T dot(const MyVec<T, dim> &rhs) { // 点乘
			T res(0);  // 初始化点乘结果为0
			for ( int i = 0; i < dim; i++ ) {
				res += (this->vec[i] * rhs.vec[i]);
			}
			return res;
		}
 		void print() {  // 打印向量
			cout << "(";
			for ( int i = 0; i < dim - 1; i++ ) {
				cout << vec[i] << ", ";
			}
			cout << vec[dim - 1] << ")" << endl;
		}
	private:
		vector<T> vec;
};

// 偏特化二维向量
template<typename T>  class MyVec<T, 2>{ // 指定偏特化的参数为dim=2，但这仍然是类模板定义
	public:
		MyVec(const vector<T> &Vec): vec(Vec) {
			if ( Vec.size() != 2 ) {
				cout << "传入vector大小不等于dim！" << endl;
			}
		};
		T dot(const MyVec<T, 2> &rhs) { // 点乘
			return this->vec[0] * rhs.vec[0] + this->vec[1] * rhs.vec[1];
		}
		void print() {  // 打印向量
			cout << "(" << this->vec[0] << ", " << this->vec[1] << ")" << endl;
		}
	private:
		vector<T> vec;
};

int main() {
	vector<int> v1 = { 1, 2, 3 };
	vector<int> v2 = { 1, 2, 4 };
	MyVec<int, 3> v3_1(v1);
	MyVec<int, 3> v3_2(v2);
	cout << "v3_1与v3_2点乘的结果为：" << v3_1.dot(v3_2) << endl;  // -> 17
	vector<int> v3 = { 1, 2 };
	vector<int> v4 = { 3, 4 };
	// 能使用特化版本的时候编译器就会尽量使用特化版本的类定义
	MyVec<int, 2> v2_1(v3);
	MyVec<int, 2> v2_2(v4);
	cout << "v2_1与v2_2点乘的结果为：" << v2_1.dot(v2_2) << endl;  // -> 11
	return 0;
}
```
在这个偏特化的二维向量的类定义中，我们依然保持 `T` 为未特化的状态，而将使用 ` dim ` 的地方都改成 `2`。这样之后不管我们定义了 ` MyVec<int, 2>` 还是 ` MyVec<float, 2>`，编译器都会自动生成相应的完全特化的类定义。
## 1.4 * 多维 vector
# 2 STL (标准模板库)
> [!info]
> C++标准库的一个强大之处就是它包含了各种各样的容器和算法，并且都是泛型（Generic）的，可以实现泛型编程（Generic Programming）。所谓泛型编程，就是在编程时不需要考虑具体数据类型，不需要寻找并使用类型与当前变量匹配的算法，而算法使用的数据结构，也就是容器，也不需要根据数据类型重复实现不同版本。  
> 
> C++标准库中，容器和算法所在的标准库子集又叫标准模板库（Standard Template Library），简称STL。它之所以比标准库多了“模板”两字，是因为模板就是C++中实现泛型编程的重要工具。的vector可以声明为不同元素类型，那就是利用了模板。
## 2.1 容器  










