---
{"dg-publish":true,"permalink":"/C++/3. C++面向对象编程进阶/","noteIcon":"","created":"2025-09-12T21:51:15.680+08:00","updated":"2025-09-15T13:27:43.567+08:00"}
---

# 1 复制控制  
关于类复制的复制构造函数和赋值操作符重载等统称为复制控制。
## 1.1 Copy Constructor (复制构造函数)  
在按值传递，以及返回非引用、非指针的返回值时，如果变量是基本数据类型，编译器会直接复制变量的值到临时变量中去。如果变量是类实例，编译器就会通过类的复制构造函数，使用现有对象的成员的数据重新构造一个临时变量：
```cpp
class MyClass {
	public:
		MyClass(int aa) : a(aa) {}
		MyClass(const MyClass &myclass) : a(myclass.a) {  // 复制构造函数
			cout << "MyClass的拷贝构造函数被调用！" << endl;
		}
	private:
		int a;
};

MyClass test(MyClass myclass) {
	cout << "test函数开始执行！" << endl;
	return myclass;
}

int main() {
	MyClass myclass1(2);
	cout << "显式调用复制构造函数！" << endl;  // -> 显式调用复制构造函数！
	MyClass myclass2(myclass1);  // -> MyClass的拷贝构造函数被调用！
	cout << "test函数调用前！" << endl; // -> test函数调用前！
	test(myclass2); // -> MyClass的拷贝构造函数被调用！\n test函数开始执行！\n MyClass的拷贝构造函数被调用！
	cout << "test函数调用后！" << endl;  // test函数调用后！
	MyClass myclassArr[3] = { myclass1, myclass1, myclass2 };  // ->MyClass的拷贝构造函数被调用！\n MyClass的拷贝构造函数被调用！\n MyClass的拷贝构造函数被调用！
	return 0;
}
```
注意复制构造函数的定义：  
```cpp
MyClass(const MyClass &myclass) : a(myclass.a) {  // 复制构造函数
	cout << "MyClass的拷贝构造函数被调用！" << endl;
}
```
这里有两个注意点：  
- 被复制的类的形参为 `const`，因为复制不需要改变原来的对象，也是出于安全而避免被修改的考虑；
- 使用按引用 `&` 传递，如果使用按值传递，就会触发复制构造，复制构造再调用复制构造函数，就会无限循环下去。
## 1.2 合成的复制构造函数  
在没有自定义 Copy Constructor 时，编译器会自动合成默认的 Copy Constructor：   
```cpp
class MyClass {
	public:
		MyClass(int aa, int bb) : a(aa), b(bb) {}
		void printValues() {
			cout << "a的值为：" << a << endl;
			cout << "b的值为：" << b << endl;
		}
	private:
		int a;
		int b;
};

MyClass test(MyClass myclass) {
	return myclass;
}

int main() {
	MyClass myclass1(2, 4);
	myclass1.printValues();
	cout << "调用test！" << endl;
	test(myclass1).printValues();  //让test返回的副本对象调用函数
	return 0;
}
--------------------------------------------------------
输出：
a的值为：2
b的值为：4
调用test！
a的值为：2
b的值为：4  // test()在传参和返回时，使用了编译器自动合成的复制构造函数
```
注意，合成复制构造函数只能实现基本的行为：复制所有成员，如果成员中有类对象，就调用/合成其 Copy Constructor。但成员为指针时，合成复制只会复制指针的值，即地址，而不会复制指针指向的对象：  
```cpp
// 浅复制
class Component {
	public:
		Component(int v) : val(v) {}
		int getVal() { return val; }
	private:
		int val;
};

class MyClass {
	public:
		MyClass(Component cp, Component *cpPtr) : comp(cp), compPtr(cpPtr) {}
		void print() {
			cout << "comp的val值为：" << comp.getVal() << endl;
			cout << "compPtr的地址为：" << compPtr << endl;
			cout << "compPtr指向对象的val值为：" << compPtr->getVal() << endl;
		}
	private:
		Component comp;
		Component *compPtr;
};

MyClass test(MyClass myclass) {
	return myclass;
}

int main() {
	Component comp1(1);
	Component comp2(3);
	MyClass myclass1(comp1, &comp2);
	myclass1.print();
	cout << "调用test！" << endl;
	test(myclass1).print();
	return 0;
}
---------------------------------------------------------
输出：
comp的val值为：1
compPtr的地址为：0x29a8bffc28
compPtr指向对象的val值为：3
调用test！
comp的val值为：1
compPtr的地址为：0x29a8bffc28
compPtr指向对象的val值为：3
```
可以发现，在合成复制构造函数调用前后，`compPtr` 的地址的地址没有变化，也就是指向的是被复制的类的成员，而不是自身所处类实例的成员。如果 `MyClass` 采用动态分配，那么在调用 `myclass1` 的析构函数之后，再次调用 `test(myclass1)` 的析构函数，会出现 `compPtr` 指向的对象已被释放的情况，这被称为浅复制。要实现深复制，需要借助自定义 Copy Constructor：  
```cpp
// 深复制
class Component {
	public:
		Component(int v) : val(v) {}
		int getVal() { return val; }
	private:
		int val;
};

class MyClass {
	public:
		MyClass(Component cp, Component *cpPtr) : comp(cp), compPtr(cpPtr) {}
		MyClass(const MyClass &myclass) : comp(myclass.comp) {  // 深复制
			this->compPtr = new Component(*myclass.compPtr); 
			// *myclass.compPtr是myclass对象的compPtr指针指向的Component对象comp2.
			// 所以new Component(*myclass.compPtr)是分配一个新的Component对象，并用*myclass.compPtr初始化它.
		}
		~MyClass() {
			delete compPtr;
		}
		void print() {
			cout << "comp的val值为：" << comp.getVal() << endl;
			cout << "compPtr的地址为：" << compPtr << endl;
			cout << "compPtr指向对象的val值为：" << compPtr->getVal() << endl;
		}
	private:
		Component comp;
		Component *compPtr;
};

MyClass test(MyClass myclass) {
	return myclass;
}

int main() {
	Component comp1(1);
	Component comp2(3);
	MyClass myclass1(comp1, &comp2);
	myclass1.print();
	cout << "调用test！" << endl;
	test(myclass1).print();
	return 0;
}
----------------------------------------------------------------------------
输出：
comp的val值为：1
compPtr的地址为：0xa2b3bff8d8
compPtr指向对象的val值为：3
调用test！
comp的val值为：1
compPtr的地址为：0x1d66285dc70
compPtr指向对象的val值为：3
(exited with code=3221226356 in 0.766 seconds)
```

注意，如果 `Has-a` 父类 `Component ` 也存在指针成员，那么其也需要自定义 Copy Constructor 以实现深拷贝。
## 1.3 Overload assignment (重载赋值操作符)  
对两个类实例使用赋值操作符 `=` ，会把右值的所有成员的值复制到左值的对象中去，这也是浅拷贝。
```cpp
class Component {
	public:
		Component(int v) : val(v) {}
		int getVal() { return val; }
	private:
		int val;
};

class MyClass {
	public:
		MyClass(Component cp) : comp(cp) {}
		void print() {
			cout << "comp的val值为：" << comp.getVal() << endl;
		}
	private:
		Component comp;
};

int main() {
	Component comp1(1);
	MyClass myclass1(comp1);
	myclass1.print();
	Component comp2(2);
	MyClass myclass2(comp2);
	myclass2.print();
	cout << "进行赋值！" << endl;
	myclass2 = myclass1; 
	myclass2.print();
	return 0;
}
-----------------------------------------------------
输出：
comp的val值为：1
comp的val值为：2
进行赋值！
comp的val值为：1
```
<font color="#ff0000">重载赋值操作符</font>可以实现深拷贝：
```cpp
class Component {
	public:
		Component(int v) : val(v) {}
		int getVal() { return val; }
	private:
		int val;
};

class MyClass {
	public:
		MyClass(int val) {
			compPtr = new Component(val);
		}
		~MyClass() {
			delete compPtr;
		}
		MyClass& operator=(const MyClass &rhs) { // 赋值操作符重载，rhs表示右值(right hand side)
			*compPtr = *rhs.compPtr; // 将右值的compPtr指向的对象复制到当前对象的compPtr指向的对象
			return *this; // 返回指向当前对象的指针
		}
		void print() {
			cout << "comp的val值为：" << compPtr->getVal() << endl;
			cout << "compPtr的值为：" << compPtr << endl;
		}
	private:
		Component *compPtr;
};

int main() {
	MyClass myclass1(1);
	myclass1.print();
	MyClass myclass2(2);
	myclass2.print();
	cout << "进行赋值！" << endl;
	myclass2 = myclass1;
	myclass2.print();
	return 0;
}
--------------------------------------------------
输出：
comp的val值为：1
compPtr的值为：0x24331f210c0
comp的val值为：2
compPtr的值为：0x24331f210e0
进行赋值！
comp的val值为：1
compPtr的值为：0x24331f210e0
```
在上述例子中，赋值前后，`myclass2.compPtr` 和 `myclass1.compPtr` 依旧指向不同的地址(不同的 `Component` 类)，只是将后者指向的 `Component` 对象赋值给了前者，而 `Component` 对象没有指针，所以只是将 `val` 的值进行了浅拷贝。  

上面例子中，在赋值之前，`myclass2` 就已经声明。但是如果用赋值进行初始化 `myclass2`，那么会调用 Copy Constructor 而不是 Overload the assignment operator：
```cpp
// 赋值操作符表示的初始化
class Component {
	public:
		Component(int v) : val(v) {}
		int getVal() { return val; }
	private:
		int val;
};

class MyClass {
	public:
		MyClass(Component cp) : comp(cp) {}
		MyClass(const MyClass &myclass) : comp(myclass.comp) {
			cout << "复制构造函数" << endl;
		}
		MyClass& operator=(const MyClass &rhs) {
			cout << "赋值操作符" << endl;
			comp = rhs.comp;
			return *this;
		}
		void print() {
			cout << "comp的val值为：" << comp.getVal() << endl;
		}
	private:
		Component comp;
};

int main() {
	Component comp(1);
	MyClass myclass1(comp);
	myclass1.print(); // -> comp的val值为：1
	cout << "进行赋值！" << endl;  // -> 进行赋值！
	MyClass myclass2 = myclass1; // -> 复制构造函数
	myclass2.print(); // -> comp的val值为：1
	return 0;
}
```
## 1.4 禁止复制  
如果不想让类对象在函数中按值传递导致复制，可以将 Copy Constructor 设置为 `private` 成员：
```cpp
class Component {
	public:
		Component(int v) : val(v) {}
		int getVal() { return val; }
	private:
		int val;
};

class MyClass {
	public:
		MyClass(Component cp) : comp(cp) {}
	private:
		MyClass(const MyClass &myclass) : comp(myclass.comp) { // 复制构造函数被私有化
			cout << "复制构造函数" << endl;
		}
		Component comp;
};

int main() {
	Component comp(1);
	MyClass myclass1(comp);
	MyClass myclass2(myclass1); // "MyClass::MyClass(const MyClass &myclass)" is inaccessible
	return 0;
}
```
# 2 Virtual Function && Polymorphism (虚函数和多态)  
所谓多态，就是为不同的数据类型的实体提供统一的接口，或者说不同的类可以共享一个函数，但各自的实现不同。继承是其中的一种方式，但是基类和派生类的同名函数会有函数隐藏的问题，为了实现多态，需要使用虚函数。  
## 2.1 Virtual Function (虚函数)  
举一个具体的例子：
```cpp
#include <iostream>
using namespace std;

class Vehicle{
	public:
		Vehicle() {}
		virtual void move() { cout << "交通工具行驶" << endl; } // 虚函数
};

class Airplane : public Vehicle{
	public:
		Airplane() {}
		virtual void move() { cout << "飞机飞行" << endl; }
};

class Car : public Vehicle{
	public:
		Car() {}
		//virtual关键词在派生类中可省略
		/*virtual*/ void move() { cout << "汽车行驶" << endl; }
};

int main() {
	Vehicle *vehicle = new Airplane();  // 将分配内存的派生类的地址用于基类指针Vehicle*的初始化
	vehicle->move();  // 因为派生类的move()是虚函数，可以被基类调用
	delete vehicle;
	vehicle = new Car();
	vehicle->move();
	delete vehicle;
	return 0;
}
---------------------------------------------------
输出：
飞机飞行
汽车行驶
```
我们可以用基类指针访问派生类的虚函数，这样，就可以<font color="#ff0000">根据用户的输入给基类指针绑定不同的派生类</font>，以实现不同的功能，这称为 <span style="background:#fff88f">Dynamic Binding</span>（动态绑定）。  

此外，派生类的关键字 `virtual` 可以省略，因为编译器会自动将*与基类的函数签名相同的派生类成员函数*识别为虚函数。基类的关键字 `virtual` 不可省略（否则输出“交通工具行驶”，因为产生隐式类型转换，只有父类和虚函数被截断保留），为了程序易读性，建议基类和派生类虚函数都加上关键字 `virtual`。  

以及，使用虚函数也需要基类的指针或引用调用，而不是基类自身：  
```cpp
#include <iostream>
using namespace std;

// 不用指针的情况
class Vehicle{
	public:
		Vehicle() {}
		virtual void move() { cout << "交通工具行驶" << endl; }
};

class Airplane : public Vehicle{
	public:
		Airplane() {}
		void move() { cout << "飞机飞行" << endl; }
};

class Car : public Vehicle{
	public:
		Car() {}
		void move() { cout << "汽车行驶" << endl; }
};

int main() {
	Airplane airplane;
	Vehicle vehicle = (Vehicle)airplane;
	vehicle.move();  // 不使用指针
	Car car;
	vehicle = (Vehicle)car;
	vehicle.move();
	return 0;
}
---------------------------------------------------
输出：
交通工具行驶
交通工具行驶
```
## 2.2 函数隐藏  
如上述，基类的虚函数是隐藏的，要访问被隐藏的函数，需要使用作用域操作符 `::`，即 `派生类实例.基类名::基类虚函数` 或者 `派生类实例的指针->基类名::基类虚函数`：
```cpp
#include <iostream>
using namespace std;

// 调用被隐藏的基类函数
class Vehicle{
	public:
		Vehicle() {}
		virtual void move() { cout << "交通工具行驶" << endl; } // 虚函数
		void printName() { cout << "交通工具" << endl; }
};

class Airplane : public Vehicle{
	public:
		Airplane() {}
		void move() { cout << "飞机飞行" << endl; }
		void printName() { cout << "飞机" << endl; }
};

class Car : public Vehicle{
	public:
		Car() {}
		void move() { cout << "汽车行驶" << endl; }
		void printName() { cout << "汽车" << endl; }
};

int main() {
	Airplane airplane;
	airplane.Vehicle::printName(); // -> 交通工具
	Vehicle *vehiclePtr = &airplane;
	vehiclePtr->Vehicle::move(); // -> 交通工具行驶
	Car car;
	car.Vehicle::printName(); // -> 交通工具
	vehiclePtr = &car;
	vehiclePtr->Vehicle::move(); // -> 交通工具行驶
	return 0;
}
```
## 2.3 纯虚函数  
如果基类不需要虚函数，或者只有派生类需要虚函数时，可以使用纯虚函数，在声明基类虚函数时“赋值”为 0：
```cpp
class Vehicle{
	public:
		Vehicle() {}
		virtual void move() = 0;  // 纯虚函数
};

class Airplane : public Vehicle{
	public:
		Airplane() {}
		void move() { cout << "飞机飞行" << endl; }
};

class Car : public Vehicle{
	public:
		Car() {}
		void move() { cout << "汽车行驶" << endl; }
};

int main() {
	Airplane airplane;
	Vehicle *vehiclePtr = &airplane;   // -> 飞机飞行
	vehiclePtr->move();
	Vehicle vehicle;  // error: object of abstract class type "Vehicle" is not allowed: function "Vehicle::move" is a pure virtual function
	vehiclePtr = &vehicle;
	vehiclePtr->move();
	return 0;
}
```

在基类的虚函数签名后面加上 `= 0`，就将其声明为了纯虚函数。这样就跳过了函数实现，同时将该类声明为 Abstract Class (抽象类)，抽象类不是完整实现的，所以不能实例化，也就是不能创建抽象类的实例，不过可以创建它的指针。
## 2.4 虚析构函数  
如果是非虚析构函数，那么在释放指向基类的指针时，会调用基类的析构函数，而不是派生类的析构函数：
```cpp
// 派生类的非虚析构函数
class Vehicle{
	public:
		Vehicle() {}
		~Vehicle() { cout << "Vehicle的析构函数被调用！" << endl; }  // 非虚析构函数
		virtual void move() = 0;
};

class Airplane : public Vehicle{
	public:
		Airplane() {}
		~Airplane() { cout << "Airplane的析构函数被调用！" << endl; }  // 非虚析构函数
		void move() { cout << "飞机飞行" << endl; }
};

class Car : public Vehicle{
	public:
		Car() {}
		~Car() { cout << "Car的析构函数被调用！" << endl; }
		void move() { cout << "汽车行驶" << endl; }
};

int main() {
	Vehicle *vehiclePtr = new Airplane();
	vehiclePtr->move(); // -> 飞机飞行
	delete vehiclePtr;  // -> Vehicle的析构函数被调用！
	vehiclePtr = new Car();
	vehiclePtr->move(); // -> 汽车行驶
	delete vehiclePtr; // -> Vehicle的析构函数被调用！
	return 0;
}
```
因为虚析构函数和虚函数都放在储存基类的内存空间的开头，而一般的析构函数会像成员函数那样，在类型转换时被截取。只需要在基类的析构函数名之前加上关键字 `virtual`，就可以创建虚析构函数，让派生类的虚构函数得以调用：  
```cpp
// 虚析构函数
class Vehicle{
	public:
		Vehicle() {}
		virtual ~Vehicle() { cout << "Vehicle的析构函数被调用！" << endl; }
		virtual void move() = 0;
};

class Airplane : public Vehicle{
	public:
		Airplane() {}
		~Airplane() { cout << "Airplane的析构函数被调用！" << endl; }
		void move() { cout << "飞机飞行" << endl; }
};

class Car : public Vehicle{
	public:
		Car() {}
		~Car() { cout << "Car的析构函数被调用！" << endl; }
		void move() { cout << "汽车行驶" << endl; }
};

int main() {
	Vehicle *vehiclePtr = new Airplane();
	vehiclePtr->move(); // -> 飞机飞行
	delete vehiclePtr;  // -> Airplane的析构函数被调用！ \n Vehicle的析构函数被调用！
	vehiclePtr = new Car();
	vehiclePtr->move(); // -> 汽车行驶
	delete vehiclePtr;  // -> Car的析构函数被调用！ \n Vehicle的析构函数被调用！
	return 0;
}
``` 
## 2.5 dynamic_cast  
在 [[C++/2. C++面向对象编程入门#1.7.4 派生类和基类的转换\|2. C++面向对象编程入门 # 派生类和基类的转换]] 提到过将派生类直接转换为基类的截断问题，而将派生类指针转换为基类指针就不会截断。而要想<font color="#ff0000">将指向派生类的基类指针转换回派生类的指针</font>，同时还能访问派生类独有的成员，则可以使用 `dynamic_cast`：  
```cpp
// dynamic_cast
class Vehicle{
	public:
		Vehicle() {}
		virtual void move() { cout << "交通工具行驶" << endl; }
};

class Airplane : public Vehicle{
	public:
		Airplane() {}
		virtual void move() { cout << "飞机飞行" << endl; } // 虚函数
		void rise() { cout << "飞机上升" << endl; }  // 一般成员函数
};

class Car : public Vehicle{
	public:
		Car() {}
		void move() { cout << "汽车行驶" << endl; } // 一般成员函数
};

int main() {
	Vehicle *vehicle = new Airplane();
	vehicle->move();  // -> 飞机飞行
	// dynamic_cast需要在尖括号中使用指针或引用类型
	Airplane *plane = dynamic_cast<Airplane *>(vehicle);
	// 判断转换是否成功
	if ( plane ) {
		plane->rise(); // -> 飞机上升
	}
	delete vehicle;
	vehicle = new Car();
	vehicle->move();  // -> 汽车行驶
	delete vehicle;
	return 0;
}
```
# 3 操作符重载  
在 [[#1.3 Overload assignment (重载赋值操作符)]] 已经介绍过一部分有关操作符重载的内容。
## 3.1 一般语法  










