---
{"dg-publish":true,"permalink":"/C++/3. C++面向对象编程进阶/","noteIcon":"","created":"2025-09-12T21:51:15.680+08:00","updated":"2025-09-13T16:28:30.140+08:00"}
---

# 1 复制控制  
关于类复制的复制构造函数和赋值操作符重载等统称为复制控制。
## 1.1 Copy Constructor (复制构造函数)  
在按值传递，以及返回非引用、非指针的返回值时，如果变量是基本数据类型，编译器会直接复制变量的值到临时变量中去。如果变量是类实例，编译器就会通过类的复制构造函数，使用现有对象的成员的数据重新构造一个临时变量：
```cpp
class MyClass {
	public:
		MyClass(int aa) : a(aa) {}
		MyClass(const MyClass &myclass) : a(myclass.a) {  // 复制构造函数
			cout << "MyClass的拷贝构造函数被调用！" << endl;
		}
	private:
		int a;
};

MyClass test(MyClass myclass) {
	cout << "test函数开始执行！" << endl;
	return myclass;
}

int main() {
	MyClass myclass1(2);
	cout << "显式调用复制构造函数！" << endl;  // -> 显式调用复制构造函数！
	MyClass myclass2(myclass1);  // -> MyClass的拷贝构造函数被调用！
	cout << "test函数调用前！" << endl; // -> test函数调用前！
	test(myclass2); // -> MyClass的拷贝构造函数被调用！\n test函数开始执行！\n MyClass的拷贝构造函数被调用！
	cout << "test函数调用后！" << endl;  // test函数调用后！
	MyClass myclassArr[3] = { myclass1, myclass1, myclass2 };  // ->MyClass的拷贝构造函数被调用！\n MyClass的拷贝构造函数被调用！\n MyClass的拷贝构造函数被调用！
	return 0;
}
```
注意复制构造函数的定义：  
```cpp
MyClass(const MyClass &myclass) : a(myclass.a) {  // 复制构造函数
	cout << "MyClass的拷贝构造函数被调用！" << endl;
}
```
这里有两个注意点：  
- 被复制的类的形参为 `const`，因为复制不需要改变原来的对象，也是出于安全而避免被修改的考虑；
- 使用按引用 `&` 传递，如果使用按值传递，就会触发复制构造，复制构造再调用复制构造函数，就会无限循环下去。
## 1.2 合成的复制构造函数  
在没有自定义 Copy Constructor 时，编译器会自动合成默认的 Copy Constructor：   
```cpp
class MyClass {
	public:
		MyClass(int aa, int bb) : a(aa), b(bb) {}
		void printValues() {
			cout << "a的值为：" << a << endl;
			cout << "b的值为：" << b << endl;
		}
	private:
		int a;
		int b;
};

MyClass test(MyClass myclass) {
	return myclass;
}

int main() {
	MyClass myclass1(2, 4);
	myclass1.printValues();
	cout << "调用test！" << endl;
	test(myclass1).printValues();  //让test返回的副本对象调用函数
	return 0;
}
--------------------------------------------------------
输出：
a的值为：2
b的值为：4
调用test！
a的值为：2
b的值为：4  // test()在传参和返回时，使用了编译器自动合成的复制构造函数
```
注意，合成复制构造函数只能实现基本的行为：复制所有成员，如果成员中有类对象，就调用/合成其 Copy Constructor。但成员为指针时，合成复制只会复制指针的值，即地址，而不会复制指针指向的对象：  
```cpp
// 浅复制
class Component {
	public:
		Component(int v) : val(v) {}
		int getVal() { return val; }
	private:
		int val;
};

class MyClass {
	public:
		MyClass(Component cp, Component *cpPtr) : comp(cp), compPtr(cpPtr) {}
		void print() {
			cout << "comp的val值为：" << comp.getVal() << endl;
			cout << "compPtr的地址为：" << compPtr << endl;
			cout << "compPtr指向对象的val值为：" << compPtr->getVal() << endl;
		}
	private:
		Component comp;
		Component *compPtr;
};

MyClass test(MyClass myclass) {
	return myclass;
}

int main() {
	Component comp1(1);
	Component comp2(3);
	MyClass myclass1(comp1, &comp2);
	myclass1.print();
	cout << "调用test！" << endl;
	test(myclass1).print();
	return 0;
}
---------------------------------------------------------
输出：
comp的val值为：1
compPtr的地址为：0x29a8bffc28
compPtr指向对象的val值为：3
调用test！
comp的val值为：1
compPtr的地址为：0x29a8bffc28
compPtr指向对象的val值为：3
```
可以发现，在合成复制构造函数调用前后，`compPtr` 的地址的地址没有变化，也就是指向的是被复制的类的成员，而不是自身所处类实例的成员。如果 `MyClass` 采用动态分配，那么在调用 `myclass1` 的析构函数之后，再次调用 `test(myclass1)` 的析构函数，会出现 `compPtr` 指向的对象已被释放的情况，这被称为浅复制。要实现深复制，需要借助自定义 Copy Constructor：  
```cpp
#include <iostream>
using namespace std;

// 深复制
// Author: 零壹快学
class Component {
	public:
		Component(int v) : val(v) {}
		int getVal() { return val; }
	private:
		int val;
};

class MyClass {
	public:
		MyClass(Component cp, Component *cpPtr) : comp(cp), compPtr(cpPtr) {}
		MyClass(const MyClass &myclass) : comp(myclass.comp) {  // 深复制
			this->compPtr = new Component(*myclass.compPtr); 
			// *myclass.compPtr是myclass对象的compPtr指针指向的Component对象comp2.
			// 所以new Component(*myclass.compPtr)是分配一个新的Component对象,并用*myclass.compPtr初始化它.
		}
		~MyClass() {
			delete compPtr;
		}
		void print() {
			cout << "comp的val值为：" << comp.getVal() << endl;
			cout << "compPtr的地址为：" << compPtr << endl;
			cout << "compPtr指向对象的val值为：" << compPtr->getVal() << endl;
		}
	private:
		Component comp;
		Component *compPtr;
};

MyClass test(MyClass myclass) {
	return myclass;
}

int main() {
	Component comp1(1);
	Component comp2(3);
	MyClass myclass1(comp1, &comp2);
	myclass1.print();
	cout << "调用test！" << endl;
	test(myclass1).print();
	return 0;
}
----------------------------------------------------------------------------
输出：
comp的val值为：1
compPtr的地址为：0xa2b3bff8d8
compPtr指向对象的val值为：3
调用test！
comp的val值为：1
compPtr的地址为：0x1d66285dc70
compPtr指向对象的val值为：3
(exited with code=3221226356 in 0.766 seconds)
```










